Отлично. Вот описание работы генератора, составленное в стиле документации для разработчиков, на основе предоставленных вами финальных файлов.

---

## Как устроен генератор классов для Telegram API

Этот документ описывает внутреннюю архитектуру и логику работы генератора кода. Его основная задача — автоматически создавать PHP-классы (DTO и запросы) на основе официальной TL-схемы Telegram в формате JSON.

Генератор спроектирован так, чтобы справляться со сложной и не всегда очевидной структурой TL-схем, включая полиморфные типы, конфликты имен и специальные случаи сериализации.

### Ключевые принципы и архитектура

Весь процесс генерации можно разбить на три последовательных этапа:

1.  **Анализ схемы (`analyzeSchema`)**: "Мозг" операции. На этом этапе генератор строит полное представление о структуре схемы, не создавая ни одного файла.
2.  **Генерация классов (`generateAbstractClasses`, `generateConcreteClasses`)**: Используя данные анализа, генератор создает PHP-файлы для абстрактных и конкретных классов.
3.  **Сборка кода (`GeneratorHelpers`)**: Набор "инструментов" в трейте, которые отвечают за генерацию конкретных фрагментов PHP-кода — от конструкторов до сложных методов сериализации.

### Этап 1: Анализ схемы — понимание иерархии

Прежде чем генерировать код, скрипт должен понять три важные концепции TL-схемы:

#### 1.1. Абстрактные типы

В Telegram API некоторые типы являются полиморфными. Например, тип `User` может быть представлен как конструктором `user` (полные данные), так и `userEmpty` (пустой пользователь).

*   **Как это определяется:** Генератор группирует все конструкторы по их возвращаемому типу. Если какой-либо тип возвращается **более чем одним** конструктором, он помечается как **абстрактный**.
*   **Результат:** Создается массив `$this->abstractTypes`, который служит справочником на последующих этапах.

#### 1.2. Псевдонимы (типы с несоответствующими конструкторами)

Часто в TL-схеме имя типа не совпадает с именем его единственного конструктора.
*   **Пример:** Тип `SavedContact` реализуется единственным конструктором `savedPhoneContact`.
*   **Как это определяется:** Генератор ищет все типы, у которых ровно один конструктор, и сравнивает имя типа с именем предиката конструктора. Если они не совпадают, эта пара (`'SavedContact' => 'savedPhoneContact'`) сохраняется в специальный массив `$this->concreteTypeToConstructorMap`.
*   **Результат:** Это позволяет генератору позже создать класс с правильным, ожидаемым именем (`SavedContact.php`), хотя он основан на конструкторе с другим именем.

#### 1.3. Подготовка данных

После анализа у генератора есть три ключевых "карты данных":
*   `$typeToConstructorsMap`: Полный список конструкторов для каждого типа.
*   `$abstractTypes`: Список всех абстрактных типов.
*   `$concreteTypeToConstructorMap`: Список всех "псевдонимов".

### Этап 2: Генерация классов — создание файловой структуры

#### 2.1. Абстрактные классы (`generateAbstractClasses`)

Для каждого типа, помеченного как абстрактный (например, `User`), создается файл `AbstractUser.php`. Его главная и единственная задача — служить "фабрикой" для своих потомков.

*   **Фабричный метод `deserialize`:** Этот статический метод содержит `match`-выражение. Он "заглядывает" в бинарный поток, читает ID конструктора и делегирует десериализацию соответствующему дочернему классу (`User::deserialize(...)` или `UserEmpty::deserialize(...)`).

#### 2.2. Конкретные классы (`generateConcreteClasses`)

Это основной цикл, который итерируется по всем конструкторам и методам из JSON-схемы.

*   **Именование:**
    1.  Сначала проверяется, не является ли текущий конструктор "псевдонимом" (из `$concreteTypeToConstructorMap`). Если да, то имя класса берется из **имени типа** (`SavedContact`).
    2.  В противном случае имя берется из **имени предиката/метода**.
    3.  Для методов к имени добавляется суффикс `Request`.
    4.  Имена в `snake_case` преобразуются в `CamelCase`, а префиксы с точкой (`messages.`) — в PHP-неймспейсы (`Messages\`).

*   **Наследование:**
    *   Если класс реализует абстрактный тип, он будет `extends Abstract...`.
    *   Иначе он наследуется напрямую от базового `TlObject`.

*   **Сборка содержимого:** Для каждого будущего класса вызывается `buildClassContent`, который, в свою очередь, использует инструменты из трейта `GeneratorHelpers` для сборки PHP-кода.

### Этап 3: "Помощники" — магия генерации кода

Трейт `GeneratorHelpers` содержит всю низкоуровневую логику.

#### 3.1. Разрешение конфликтов имен (`buildConstructorParams`, `getDeserializationCodeForType`)

Это самый сложный и важный механизм генератора. Он решает проблему, когда короткие имена классов совпадают, но их полные пути (FQCN) — нет.

*   **Контекст:** Методы получают не только информацию о параметре, который нужно сгенерировать, но и полный контекст: имя класса, который сейчас генерируется (`$currentClassName`), и FQCN его родителя (`$parentFqcn`).
*   **Правило конфликта:** Конфликт возникает, если короткое имя типа параметра совпадает с коротким именем текущего класса ИЛИ его родителя, **И при этом их FQCN различаются**.
*   **Решение:** Если конфликт обнаружен, для импортируемого класса создается **алиас** (например, `use ...\Base\Type as BaseType`). Этот алиас затем используется в type-hint'ах конструктора и в вызовах `deserialize`, что решает все проблемы с двусмысленностью и рекурсией.

#### 3.2. Сериализация (`buildFlagsLogic`, `getSerializationCodeForType`)

*   **Флаги:** Генератор анализирует условные поля (`flags.0?true`) и строит код для вычисления битовой маски `flags`. Затем он генерирует `if`-блоки для условной записи полей в поток.
*   **Типы:** Для каждого поля генерируется вызов соответствующего метода сериализатора (`$serializer->int32()`, `$serializer->bytes()`, `$object->serialize()`).

#### 3.3. Специальные типы (`getSpecialTypeHandling`)

Этот метод — "швейцарский нож" для обработки странностей протокола.

*   **`DataJSON` vs `JSONValue`:** Генератор знает, что `DataJSON` — это простая строка с JSON, а `JSONValue` — сложная TL-структура.
    *   При **десериализации** он вызывает разные методы: для `DataJSON` — простой `json_decode`, для `JSONValue` — сложный рекурсивный парсер `deserializeJsonValue`.
    *   При **сериализации** `JSONValue` используется прагматичный "хак": создается временный объект `DataJSON`, который и сериализуется. Это работает, потому что серверы Telegram достаточно гибки, чтобы принять такой формат.

В результате этого конвейера мы получаем набор чистых, строго типизированных и готовых к использованию PHP-классов, которые точно отражают сложную структуру Telegram API и скрывают от конечного разработчика всю низко-уровневую магию сериализации и разрешения типов.